%-------------------------------------------------------------------------------
\section{Quasinormalization}
%-------------------------------------------------------------------------------


\subsection{Overview}
%-------------------------------------------------------------------------------


In this section we prove that all welltyped terms can be reduced to an $1$
normal form. A term is in $1$ normal form if it has no redexes of level
$1$ or higher.

The level of a type is the level of the lowest sort the type lives in up to
reduction. The level of a redex is the level of the type of its function term.

Here we give an overview of the proof. The needed definitions and theorems will
be made precise in the subsequent sections.

A term $t$ is welltyped if there is a context $\Gamma$ and a type term $T$ such
that $\Gamma \vdash t : T$ is satisfied. Without restriction of generality we
can assume that $\Gamma \vdash t : T$ has been derived with a finite set of
sorts $S_n$. To find $n$ just look into the derivation of $\Gamma \vdash t : T$
and find the highest sort $\Any_n$. Then it is guaranteed that the derivation is
possible with the finite sort set $S_n$.

If we restrive ourselves to the finite sort set $S_n$ then the highest level of
all types is $n$ and the highest level of any redex is $n$ as well.
I.e. all derivable terms are in $n+1$ normal form.

We want to prove that we can transform any welltyped term $t$ derived with the
finite sort set $S_n$ into $1$ normal form. We do this by downward
induction from $n+1$ to $1$.

The induction start is trivial, because all terms derived with the finite sort
set $S_n$ are in $n+1$ normal form.

For the induction step from $i+1$ down to $i$ we can assume the induction
hypothesis that we can reduce any welltyped term to $i+1$ normal form.




\begin{comment}

    Basic proof idea
    ============================================================

    Levels of a redex (via level of the type of the function term)
    ------------------------------------------------------------

    Each term which is not in normal form has a nonempty set of redexes. Each of
    these redexes has a function term and this function term has a minimal type.

    Each type has a level which is its lowest sort modulo reduction. Therefore
    we can say that each redex has a level (the level of the minimal type of its
    function term). The number of redexes in a term is finite. There is a
    highest level of all redexes a term.

    We say that a term is s-normal, if it has no redexes of level s or higher.
    If s is the highest level of a redex in a term, then the term is s+1 normal.


    Degree of a redex
    ------------------------------------------------------------

    For all terms which are s+1 normal it is possible the define a degree for
    all s level redexes.

    We can reduce each term where s is the highest level of all its redexes into
    s-normal form. We do this by repeatedly reducing the rightmost redex of
    level s.



\end{comment}



\begin{comment}
    Level:

        A set of sorts a type can live in, even if beta reduced.

        Note:
            Beta reduction can reduce the sort. E.g.

                (\ (A: Any (i+k+1)) := A) (Any i) ~> Any i

            where `Any i` has type  `Any (i+1)` and
            `(\ (A: Any (i+k+1)) := A) (Any i)` has type `Any (i+k+1)` because
            the result of the function term is `A` which has type `Any (i+k+1)`.


    Level of a redex:

        All redexes have a function term which has a minimal type of the form
        'all (x: A): B' (or beta equivalents). The level of this type is the
        level of a redex.


    j-normal term:

        Does not have redexes of level 'upper (Any j)' or subsets of it.

        0-normal terms are normal terms, because they contain no redexes.


    Proof idea:

        In ECCn a redex with sort set upper (Any n) is not possible. Therefore
        we have a function rn which reduces any term to its n-normal form. Since
        all terms are in n-normal form rn is the identity function.

        Induction step: Assume there is a reduction function ri+1, find a
        reduction function ri.

            We look into redexes whose sort set of its function term type is
            upper (Any i). We can transform all these types into i+1 normal form
            via ri+1. The normalized type is a sort or a product or a base term.
            We can compute the degree of all these types.

            We use the triple

                (i, d, n)

            where d is the maximal degree of all these types and n is the number
            of redexes which have this maximal degree.

            We reduce the rightmost redex of degree d and claim that this
            reduces n by one. We continue until n=0 i.e. there are no more
            redexes of degree d.

            We continue this process until there are no more redexes of level i.

            The i-normal term is unique because the rightmost redex is unique.
            Therefore we have found the reduction function ri.

        Crucial in the construction: The reduction of the rightmost redex of the
        highest degree does not make new redexes of this degree.
\end{comment}







\subsection{Level}
%------------------------------------------------------------


\begin{definition}
    The \emph{Level} $\Level(T)$ of a type T is the level of the minimal sort
    the type lives in up to reduction.
\end{definition}


\begin{theorem}
    \label{thm:LevelTypeSafeSubstitution}
    %------------------------------------------------------------
    Type safe substitution decreases the level of a type.
    $$
    \rulev{
        \Gamma \vdash a : A
        \\
        \Gamma, x^A \vdash B: s
    }
    {
        \Level(B[a/x]) \le \Level(B)
    }
    $$
    \begin{proof}
        Let's say the level of $B$ is $i$. Then there exists by definition of
        the level a reduct $C$ of $B$ such that $\Gamma, x^A \vdash C: \Any_i$
        is valid. By the substitution lemma~\ref{SubstitutionLemma} we get
        $\Gamma \vdash C[a/x]: \Any_i$. Since $C[a/x]$ lives in the sort
        $\Any_i$ and is a reduct of $B[a/x]$ the level of $B[a/x]$ is less or
        equal $i$.
    \end{proof}
\end{theorem}




\begin{theorem}
    \label{thm:LevelProduct}
    %------------------------------------------------------------
    The level of a nonpropositional product is the maximal level of the argument
    type and the result type.
    $$
    \ruleh{
        \Level(B) > 0
    }
    {
        \Level(\Pi x^A.B) = \max(\Level(A), \Level(B))
    }
    $$
    \begin{proof}
        Because of cumulativity we have
        $$
        \rulev{
            \Gamma \vdash A: \Any_i
            \\
            \Gamma,x^A \vdash B: \Any_j
            \\
            i,j > 0
        }
        {
            \Gamma \vdash \Pi x^A. B : \Any_{\max(i,j)}
        }
        $$
        Since reduction of a product does not change its shape, the levels of
        the argument and result type determine uniquely the level of the
        product.
    \end{proof}

    Note the restriction to nonpropositional products. The level of a
    propositional product is 0 regardless of the level of the argument type.
\end{theorem}




\begin{theorem}
    \label{thm:LevelSubtypeEquivalence}
    %------------------------------------------------------------
    The level of a type respects subtyping and betaequivalence.
    \begin{enumerate}
        \item $ A \betaeq B \imp \Level(A) = \Level(B)$

        \item $ A <_i B \imp \Level(A) \le \Level(B) $
    \end{enumerate}

    \begin{proof}
        \ \begin{enumerate}
            \item In case of betaequivalence $A$ and $B$ have a common reduct
                $C$ with $\Level(A) = \Level(C) = \Level(B)$.

            \item By induction on $<_i$.
                \begin{enumerate}
                    \item The base case is trivial.

                    \item For the induction step we assume $B_1 <_i B_2 \imp
                        \Level(B_1) \le \Level(B_2)$ and have to prove
                        $$
                            \Level(\Pi x^A.B_1) \le \Level(\Pi x^A. B_2)
                        $$
                        under the assumption $ \Pi x^A. B_1 <_{i+1} \Pi x^A.
                        B_2$ (which implies $\Level(B_1) \le \Level(B_2)$ by the
                        induction hypothesis).

                        If $B_1$ is a proposition i.e. $\Level(B_1) = 0$, then
                        the goal is trivial.

                        So we assume $B_1$ is not a
                        proposition which implies that $B_2$ is not a
                        proposition either. With the help of
                        theorem~\ref{thm:LevelProduct} we derive
                        $$
                        \begin{array}{lll}
                            \Level(\Pi x^A. B_1)
                            & = & \max(\Level(A), \Level(B_1)
                            \\
                            & \le & \max(\Level(A), \Level(B_2))
                            \\
                            & = & \Level(\Pi x^A. B_2)
                        \end{array}
                        $$
                \end{enumerate}
        \end{enumerate}
    \end{proof}
\end{theorem}



\begin{theorem}
    \label{thm:LevelApplication}
    %------------------------------------------------------------
    Let $f a$ be an application where $F$ is a minimal type of $f$ and $R$ is a
    minimal type of $f a$. Then the level of $F$ is greater equal the level of
    $R$.
    $$
    \rulev{
        \Gamma \vdashmin f : F
        \\
        \Gamma \vdashmin f a: R
    }
    {
        \Level(F) \ge \Level(R)
    }
    $$
    \begin{proof}
        Without loss of generality we assume that $F$ is not a proposition,
        because for propositions the goal is trivial.

        Since $f$ is a function positition according
        to~\ref{thm:MinimalTypeFunctionTerm} there is a minimal type of the form
        $\Pi x^A.B$ betaequivalent to $F$.
        $$
        \begin{array}{lllll}
            \Level(F)
            & = & \Level(\Pi x^A.B) &~\ref{thm:LevelSubtypeEquivalence}
            \\
            & \ge  & \Level(B)
            &~\ref{thm:LevelProduct}
            \\
            & \ge & \Level(B[a/x]
            &~\ref{thm:LevelTypeSafeSubstitution}
            \\
            & = & \Level(R)
        \end{array}
        $$
    \end{proof}
\end{theorem}


\begin{theorem}
    \label{thm:LevelRepeatedApplication}
    %------------------------------------------------------------
    Let $f a_1 \ldots a_n$ is an application where $F$ is a minimal type of $f$
    and $R_i$ is a minimal type of $f a_1 \ldots a_i$ with $i \le n$. Then the
    level of $F$ is greater equal to the level of $R_n$.

    \begin{proof}
        We prove this fact by repeated application of the previous
        theorem~\ref{thm:LevelApplication}.
        $$
        \begin{array}{lll}
            \Level(F) & \ge & \Level(R_1)
            \\
            & \ge & \Level(R_2)
            \\
            \ldots
            \\
            & \ge & \Level(R_n)
        \end{array}
        $$
    \end{proof}
\end{theorem}








\subsection{$i$-Normal Terms}
%------------------------------------------------------------

With the help of the level of a type we define the level of a redex by
\begin{definition}
    \emph{Level of a redex}
    %------------------------------------------------------------

    The level of a redex $(\lambda x^A. e) a$ is the level of the minimal type of
    the function term $\lambda x^A. e$.
\end{definition}

The level of a redex is welldefined because all minimal types are betaequivalent
and due to~\ref{thm:LevelSubtypeEquivalence} all betaequivalent types have the
same level.



\begin{definition}
    \emph{Welltyped $i$-normal terms}

    A welltyped term $t$ is $i$-normal if it contains no redexes with a level of
    $i$ or higher.
\end{definition}




\begin{theorem}
    \label{thm:NormalBaseTerm}
    %-----------------------------
    \emph{Let $fa$ be a welltyped $i+1$-normal type whose level is $i$ or lower
    i.e. $\Level(f a) \le i$.
    In that case $f a$ is a base term.}

    \begin{proof}
        We prove the more general theorem using $f a \vec b$ as the welltyped
        $i+1$-normal term with $\Level(f a \vec b) \le i$ where $\vec b$ is a
        possibly empty sequence of additional arguments.
        We prove that $f a \vec b$ is a base term.

        Since $f a \vec b$ is a type, its type has to be a sort i.e. we have
        $\Gamma \vdashmin f a \vec b: \Any_j$ for some $\Gamma$ and $j$. Since the
        level of the type is $i$ or lower, we have $i \le j$.

        The proof goes by induction on the structure of the function term $f$.
        \begin{enumerate}

            \item $f$ can neither be a sort nor a product. This would contradict
                the fact that $f b \vec c$ is welltyped.

            \item If $f$ is a variable then $f a \vec b$ is by definition a base
                term.

            \item $f$ is the application $ga_0$: In that case $ga_0 a \vec b$ is
                a welltyped $i+1$-normal type of level $i$ or lower.
                From the induction hypothesis for $g$ we conclude that $g a_0
                a \vec b = f a \vec b$ is a base term.

            \item $f$ is an abstraction:
                Say $F$ is a minimal type of $f$.
                By~\ref{thm:LevelRepeatedApplication} we have $\Level(F) \ge
                \Level(\Any_j) = j + 1 > i$. This contradicts the assumption that
                $f a \vec b$ is $i+1$ normal i.e. does not have redexes of level
                $i + 1$ or higher. Therefore $f$ cannot be an abstraction.
        \end{enumerate}
    \end{proof}
\end{theorem}


\begin{theorem}
    \label{thm:FormNormalTypes}
    %------------------------------------------------------------
    \emph{Form of Normal Types} A welltyped $i+1$-normal type $T$ whose level is
    $i$ or lower is either a sort, a product or a base term.


    \begin{proof}
        By induction of the structure of $T$.
        \begin{itemize}

            \item If $T$ is a sort or a product or a variable then the goal is
                trivial.

            \item $T$ cannot be an abstraction because the type of an
                abstraction cannot be a sort i.e. it cannot be a welltyped type.

            \item If $T$ is an application it is a base term. This is an
                immediate consequence of~\ref{thm:NormalBaseTerm}.
        \end{itemize}
    \end{proof}
\end{theorem}








\subsection{Degree}
%------------------------------------------------------------

\begin{definition}
    \label{def:TypeDegree}
    \emph{The $i$-degree of a welltyped $i+1$-normal type is defined recursively
    by}

    $$
    \Degree_i(T) :=
    \dcases{
        \Degree_i(T) &:=& 0 \quad\text{if } \Level(T) \ne i
        \\
        \Degree_i(s) &:=& 0
        \\
        \Degree_i(x \vec a) &:=& 0
        \\
        \Degree_i(\Pi x^A.B) &:=&
        1 + \Degree_i(A) +  \Degree_i(B)
    }
    $$

    Note that the degree is welldefined by~\ref{thm:FormNormalTypes} which
    asserts that a level $i$ type $T$ is either a sort or a base term or a
    product if it is $i+1$-normal.
\end{definition}



\begin{theorem}
    Welltyped betaequivalent types which are $i+1$-normal have the same degree.
    \label{thm:BetaEquivalentSameDegree}
    %----------------------------------------------------------------------
    \begin{proof}
        Assume that $T_1$ and $T_2$ are betaequivalent and $i+1$-normal.
        By~\ref{thm:LevelSubtypeEquivalence} they have the same level. If the
        level is not $i$, then the goal is trivial. Therefore we assume that the
        level is $i$.

        We prove $\Level(T_1) = \Level(T_2)$ by induction on the structure of
        $T_1$.

        By~\ref{thm:FormNormalTypes} we know that both are either sorts, base
        terms or products. Welltyped sorts, base terms and products can only be
        betaequivalent if they are both sorts, base terms or products respectively.


        For sorts and base terms the goal is evident by definition that
        they have the same degree (namely 0). If both are products the goal
        follows from the induction hypothesis.
    \end{proof}
\end{theorem}



\begin{theorem}
    Subtyping of welltyped $i+1$-normal types of level $i$ respects the degree.
    $$
    \rulev{
        T \le U
        \\
        \Level(T) = \Level(U) = i
    }
    {
        \Degree_i(T) \le \Degree_i(U)
    }
    $$
    \begin{proof}
        $T$ and $U$ are $i+1$-normal and of level $i$. Therefore both are either
        sorts, baseterms or products by~\ref{thm:FormNormalTypes}.

        In case $T$ and $U$ are betaequivalent, the goal follows immediately
        from \ref{thm:BetaEquivalentSameDegree}.

        In the other case there exist some $k$, $V_1$ and $V_2$ such that $V_1
        <_k V_2$, $T \reducestar V_1$ and $U \reducestar V_2$ are valid.

        We prove the remaining case by induction on the structure of $T$ where
        we have to consider only the cases that $T$ is either a sort, a base
        term or a product.

        \begin{enumerate}
            \item $T$ is a sort (say $s_T$): This is possible only if $k=0$. This
                implies that $U$ is a sort (say $s_U$) as well with $s_T <_0
                s_U$ which implies the goal. 

            \item $T$ is a base term: This case is impossible, because reduction
                does not change the structure of a base term and $V_1$
                cannot be a base term.

            \item $T$ is a product (say T = $\Pi x^{A_1}. B_1$): This implies that
                $V_1$ and $V_2$ are products as well and $k > 0$. Therefore $U$ has
                to by a product as well, say $U = \Pi x^{A_2}. B_2$.

                Furthermore from $V_1 <_k V_2$ we infer than $A_1 \betaeq A_2$
                and $B_1 \le B_2$. From~\ref{thm:BetaEquivalentSameDegree} and
                the induction hypothesis we infer $\Degree_i(A_1) =
                \Degree_i(A_2)$ and $\Degree_i(B_1) \le \Degree_i(B_2)$ which
                implies by the definition of the degree $\Degree_i(T) \le
                \Degree_i(U)$.
        \end{enumerate}
    \end{proof}
\end{theorem}





\subsection{Normalization}
%------------------------------------------------------------

In this section we prove that all welltyped terms have a 1-normal form. Without
loss of generality we restrict ourselves to welltyped terms derivable with a
finite sort set $S_n$.

We prove the more general statement that all welltyped terms derivable with the
finite sort set $S_n = \set{\Any_0, \Any_1, \Any_2, \ldots, \Any_n}$ have an
$i$-normal form for all $0 < i \le n + 1$. The proof goes by induction from $i =
n+1$ down to $1$. The base case $i = n + 1$ is trivial because there are no
level $n+1$ level types and therefore no $n+1$ level redexes. All terms are
$n+1$-normal.

In the following we concentrate on the induction step assuming that there exists
an $i+1$-normal form for all welltyped terms and construct from that an
$i$-normal form of the term.

\begin{definition}
    The \emph{$i$-degree of a redex}
    %------------------------------------------------------------
    in an $i+1$ normal term under the assumption
    that every welltyped term is reducible to an $i+1$ normal form is defined as
    the $i$-degree of the $i+1$-normalized minimal type of the function term of
    the redex.

    Note that the notion of the $i$-degree of a redex is welldefined, because
    all minimal types of the function term are betaequivalent and
    by~\ref{thm:BetaEquivalentSameDegree} all betaequivalent types have the same
    degree.
\end{definition}



\begin{definition}
    The \emph{complexity measure of an $i+1$-normal term $t$}
    %------------------------------------------------------------
    is defined as the sequence of numbers
    $$
        (d,  \, n_d \, \ldots \, n_1)
    $$
    where $d$ is the highest $i$-degree of a $i$-level redex in $t$ and $n_k$ is the
    number of $i$-level redexes with $i$-degree $k$.

    We consider the complexity measure as lexicographically sorted where $d$ has
    the highest significance and the the significance of $n_{k+1}$ is higher
    than the significance of $n_k$.
\end{definition}


\begin{definition}
    An \emph{i-normalization step} $t \torel{i} u$
    %------------------------------------------------------------
    of an $i+1$-normal welltyped
    term $t$ consists of reducing the rightmost redex of level $i$ in the term.
\end{definition}



\begin{theorem}
    Each $i$-normalzation step of an $i$-level redex with $i$-degree $k$ does
    not increase the number of $i$-level redexes by copying (i.e. multiplying)
    them.
    \label{thm:INormalizationNotCopy}

    \begin{proof}
        Since an $i$-normalization step reduces the rightmost $i$-level redex
        $(\lambda x^A.e)a \reduce e[a/x]$ the argument $a$ cannot contain any
        $i$-level redex.
    \end{proof}
\end{theorem}



\begin{theorem}
    Each $i$-normalzation step of an $i$-level redex with $i$-degree $k$ might
    create new redexes of $i$-degree lower than $k$.
    \label{thm:INormalizationDecreasesDegree}

    \begin{proof}
        MISSING
    \end{proof}
\end{theorem}












\begin{theorem}
    \label{thm:NewRedexCreation}
    \emph{Creation of new redexes during beta reduction} There are only three
    possibilities to create new redexes during a beta reduction which does the
    reduction $(\lambda x^A.e) a \reduce \sub a x e$ on any subterm of a term.

    $$
    \begin{array}{lll}
        (\lambda x^A. \ldots xb \ldots) (\lambda y^B. e)
        &\reduce&
        \ldots (\lambda y^B.e) b \ldots
        %
        \\
        %
        (\lambda x^A. x)(\lambda y^B. e) b
        &\reduce&
        (\lambda y^B. e) b
        %
        \\
        %
        (\lambda x^A . \lambda y^B. e) a b
        &\reduce&
        (\lambda y^{B[a/x]}. e[a/x]) b
    \end{array}
    $$
    where $xb$ in the first case is not the argument of an application i.e. $xb$
    is in a head position.

    \begin{proof}
        A redex consists of an abstraction applied to an argument. Both must
        have been in the original expression and come together after the
        reduction. If the abstraction is in the argument of the redex then the
        argument must be the abstraction. The abstraction replaces the bound
        variable of the original redex.

        If the original redex has $x b$ in a head position, then the
        substitution of the abstraction for $x$ creates a new redex. This is the
        first case.

        If the original redex has only the bound variable $x$ but not applied to
        an argument, then the body of the original redex must be $x$ and the
        argument comes from an argument in the original expression which follows
        the original redex. This is the second case.

        The third possibility has an abstraction without argument (otherwise it
        were already a redex) as the body of the original abstraction and the
        argument of the newly created redex is the argument following the
        argument of the original redex.
    \end{proof}
\end{theorem}



\begin{theorem}
    \emph{A sequence of normalization steps
        according to
        definition~\ref{def:NormalizationStep}
        of an $s+1$-normal term $t$
        when $s$
        is not a propositional sort
        ends after a finite number of steps
        in an $s$-normal unique term.}

    \begin{proof}

        Let
        $$
            n_d n_{d-1} \ldots n_2 n_1
        $$
        be a sequence of numbers where $d$ is the maximal degree of all redexes
        in $t$ with sort set $\upper s$ where $s$ is not a propositional sort.
        The number $n_i$ is the number of redexes in the term $t$ of degree $i$
        and with sort set $\upper s$.

        Then in the reduction sequence
        $$
            t = t_0 \torel {q_s} t_1 \torel{q_s} t_2 \torel{q_s} \ldots
        $$
        each reduction step decreases the number sequence in the lexicographic
        order. Since the lexicographic order is a wellorder, the reduction
        sequence ends after a finite number of steps.
    \end{proof}
\end{theorem}
